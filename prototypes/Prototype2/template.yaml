AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: 'Combined template for Serverless RAG Q&A application using Knowledge Base, Agents, OpenSearch Serverless'

Parameters:

  AOSSCollectionName:
    Description: Name of the Amazon OpenSearch Service Serverless (AOSS) collection.
    Default: inagent-kb
    Type: String
    MinLength: 1
    MaxLength: 21
    AllowedPattern: ^[a-z0-9](-*[a-z0-9])*
    ConstraintDescription: Must be lowercase or numbers with a length of 1-63 characters.

  AOSSIndexName:
    Description: Name of the vector index in the Amazon OpenSearch Service Serverless (AOSS) collection.
    Default: inagent-io
    Type: String

  KnowledgeBaseName:
    Default: instantagent-kb
    Type: String
    Description: The name of the knowledge base.

  KnowledgeBaseDescription:
    Default: Answer based only on information contained in knowledge base. 
    Type: String
    Description: The description of the knowledge base.

  AgentName:
    Default: instantagent1
    Type: String
    Description: The name of the agent.

Resources:

  # DynamoDB Table for Chat Logs
  ChatLogTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Join
        - "-"
        - - "bedrock-chat-logs"
          - !Select
            - 0
            - !Split
              - "-"
              - !Select
                - 2
                - !Split
                  - "/"
                  - !Ref "AWS::StackId"
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: id
          AttributeType: S
        - AttributeName: timestamp
          AttributeType: N
      KeySchema:
        - AttributeName: id
          KeyType: HASH
        - AttributeName: timestamp
          KeyType: RANGE
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      SSESpecification:
        SSEEnabled: true


  AdminUser:
    Type: AWS::IAM::User
    Properties:
      UserName: 'leap-admin'
      Path: "/"
      

  AdminUserSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: 'leap-admin-credentials'
      GenerateSecretString:
        SecretStringTemplate: '{"username": "cf-admin-user"}'
        GenerateStringKey: "password"
        PasswordLength: 16
        ExcludeCharacters: '"@/\\'

  AdminUserAccessKey:
    Type: AWS::IAM::AccessKey
    Properties:
      UserName: !Ref AdminUser

  AdminUserPolicy:
    Type: AWS::IAM::UserPolicy
    Properties:
      UserName: !Ref AdminUser
      PolicyName: AdminAccess
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action: '*'
            Resource: '*'

  # First adding the Lambda Execution Role that was missing
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource: !GetAtt ChatLogTable.Arn
        - PolicyName: OpenSearchServerlessAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: 
                  - 'aoss:UpdateAccessPolicy'
                  - 'aoss:CreateAccessPolicy'
                  - 'aoss:GetAccessPolicy'
                  - 'aoss:BatchGetCollection'
                  - 'aoss:APIAccessAll'
                  - 'aoss:ListCollections'
                  - 'aoss:DescribeCollection'
                Resource: '*'
              - Effect: Allow
                Action:
                  - 'aoss:CreateIndex'
                  - 'aoss:UpdateIndex'
                  - 'aoss:DescribeIndex'
                  - 'aoss:ReadDocument'
                  - 'aoss:WriteDocument'
                Resource: !Sub 'arn:aws:aoss:${AWS::Region}:${AWS::AccountId}:collection/${AOSSCollectionName}'

  # Basic Lambda Execution Role for Delete S3 Bucket function
  LambdaBasicExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Path: /
      Policies:
        - PolicyName: S3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: arn:aws:logs:*:*:*
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                  - s3:DeleteObject
                  - s3:ListBucket
                Resource:
                  - !Sub arn:aws:s3:::${S3Bucket}
                  - !Sub arn:aws:s3:::${S3Bucket}/*

  S3Bucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Description: Creates an Amazon S3 bucket to hold source data for the knowledge base.
    Properties:
      BucketName: !Join
      - "-"
      - - "leapkb"
        - !Select
          - 0
          - !Split
            - "-"
            - !Select
              - 2
              - !Split
                - "/"
                - !Ref "AWS::StackId"

       
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256

  BucketCleanupResource2:
    Type: Custom::S3Cleanup
    DependsOn: S3Bucket
    Properties:
      ServiceToken: !GetAtt S3CleanupFunction.Arn
      BucketName: !Ref S3Bucket

  AmazonBedrockExecutionRoleForKnowledgeBase:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join
      - "-"
      - - "kbexec-role"
        - !Select
          - 0
          - !Split
            - "-"
            - !Select
              - 2
              - !Split
                - "/"
                - !Ref "AWS::StackId"
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: 
                - bedrock.amazonaws.com
                - aoss.amazonaws.com
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                "aws:SourceAccount": !Sub "${AWS::AccountId}"
              ArnLike:
                "AWS:SourceArn": !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:knowledge-base/*"
      Path: /
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonBedrockFullAccess
      Policies:
        - PolicyName: S3ReadOnlyAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:Get*
                  - s3:List*
                  - s3-object-lambda:Get*
                  - s3-object-lambda:List*
                Resource:
                  - !Sub arn:aws:s3:::${S3Bucket}
                  - !Sub arn:aws:s3:::${S3Bucket}/*
        - PolicyName: AOSSAPIAccessAll
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - aoss:APIAccessAll
                  - aoss:DeleteDocument  
                  - aoss:UpdateDocument 
                Resource: !Sub arn:aws:aoss:${AWS::Region}:${AWS::AccountId}:collection/*
        - PolicyName: BedrockListAndInvokeModel
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:ListCustomModels
                  - bedrock:InvokeModel
                Resource: '*'
        - PolicyName: OpenSearchServerlessAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: 
                  - aoss:CreateCollection
                  - aoss:DeleteCollection
                  - aoss:CreateAccessPolicy
                  - aoss:CreateSecurityPolicy
                  - aoss:GetAccessPolicy
                  - aoss:UpdateAccessPolicy
                  - aoss:BatchGetCollection
                  - aoss:CreateIndex
                  - aoss:DeleteIndex
                  - aoss:UpdateIndex
                Resource: '*'

  Collection:
    Type: 'AWS::OpenSearchServerless::Collection'
    Properties:
      Name: !Ref AOSSCollectionName
      Type: VECTORSEARCH
      StandbyReplicas: DISABLED
      Description: Collection to hold vector search data
    DependsOn: EncryptionPolicy

  NetworkPolicy:
    Type: 'AWS::OpenSearchServerless::SecurityPolicy'
    Properties:
      Name: !Join
      - "-"
      - - "net-pol"
        - !Select
          - 0
          - !Split
            - "-"
            - !Select
              - 2
              - !Split
                - "/"
                - !Ref "AWS::StackId"
      Type: network
      Description: Network policy for the AOSS collection
      Policy: !Sub >-
        [{"Rules":[{"ResourceType":"collection","Resource":["collection/${AOSSCollectionName}"]}, {"ResourceType":"dashboard","Resource":["collection/${AOSSCollectionName}"]}],"AllowFromPublic":true}]

  EncryptionPolicy:
    Type: 'AWS::OpenSearchServerless::SecurityPolicy'
    Properties:
      Name: !Join
      - "-"
      - - "enc-pol"
        - !Select
          - 0
          - !Split
            - "-"
            - !Select
              - 2
              - !Split
                - "/"
                - !Ref "AWS::StackId"
      Type: encryption
      Description: Encryption policy for the AOSS collection
      Policy: !Sub >-
        {"Rules":[{"ResourceType":"collection","Resource":["collection/${AOSSCollectionName}"]}],"AWSOwnedKey":true}

  DataAccessPolicy:
    Type: 'AWS::OpenSearchServerless::AccessPolicy'
    Properties:
      Name: "accpol545"
      Type: data
      Description: Access policy for the AOSS collection
      Policy: !Sub >-
        [{"Description":"Access for cfn user","Rules":[{"ResourceType":"index","Resource":["index/${AOSSCollectionName}/*"],"Permission":[
                    "aoss:CreateIndex",
                    "aoss:UpdateIndex",
                    "aoss:DescribeIndex",
                    "aoss:ReadDocument",
                    "aoss:WriteDocument"
                  ]},
        {"ResourceType":"collection","Resource":["collection/${AOSSCollectionName}"],"Permission":["aoss:*"]}],
        "Principal":["${AdminUser.Arn}", "${AmazonBedrockExecutionRoleForKnowledgeBase.Arn}", "${LambdaExecutionRole.Arn}"]}]
    DependsOn: AmazonBedrockExecutionRoleForKnowledgeBase

  OpenSearchVectorIndexLambda:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: |
          import os
          import sys
          import subprocess
          import json
          import traceback
          import boto3
          import urllib3
          import logging
          import base64
          import time
          import random
          import string
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          

          def install_and_import_dependencies():
              subprocess.check_call([sys.executable, "-m", "pip", "install", "--target", "/tmp", "requests", "requests_aws4auth"])
              sys.path.append('/tmp')
              global requests, AWS4Auth
              import requests
              from requests_aws4auth import AWS4Auth
              logger.info("Dependencies installed and imported successfully")

          def generate_policy_version():
              timestamp = int(time.time())
              random_string = ''.join(random.choices(string.ascii_lowercase + string.digits, k=10))
              version_string = f"{timestamp}-{random_string}"
              return base64.b64encode(version_string.encode()).decode().rstrip('=')

          def send_cfn_response(event, context, response_status, response_data, physical_resource_id=None, reason=None):
              response_url = event['ResponseURL']
              logger.info(f"CFN response URL: {response_url}")

              response_body = {
                  'Status': response_status,
                  'Reason': reason or f"See the details in CloudWatch Log Stream: {context.log_stream_name}",
                  'PhysicalResourceId': physical_resource_id or context.log_stream_name,
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  'NoEcho': False,
                  'Data': response_data
              }

              json_response_body = json.dumps(response_body)
              logger.info(f"CFN response body: {json_response_body}")

              headers = {
                  'content-type': '',
                  'content-length': str(len(json_response_body))
              }

              try:
                  http = urllib3.PoolManager()
                  response = http.request('PUT', response_url, headers=headers, body=json_response_body)
                  logger.info(f"CFN response status code: {response.status}")
              except Exception as e:
                  logger.error(f"Error sending CFN response: {str(e)}")

          def handler(event, context):
              logger.info(f"Received event: {json.dumps(event)}")
              
              try:
                  install_and_import_dependencies()

                  region = os.environ['AWS_REGION']
                  service = 'aoss'
                  credentials = boto3.Session().get_credentials()
                  awsauth = AWS4Auth(credentials.access_key, credentials.secret_key, region, service, session_token=credentials.token)
                  
                  collection_name = event['ResourceProperties']['CollectionName']
                  index_name = event['ResourceProperties']['IndexName']
                  
                  client = boto3.client('opensearchserverless')
                  
                  logger.info(f"Attempting to get collection details for {collection_name}")
                  collection_data = client.batch_get_collection(names=[collection_name])['collectionDetails'][0]
                  collection_endpoint = collection_data['collectionEndpoint']
                  
                  logger.info(f"Collection endpoint: {collection_endpoint}")

                  if event['RequestType'] == 'Create' or event['RequestType'] == 'Update':
                      logger.info("Going to sleep")
                      time.sleep(120)
                      logger.info("Woke up")
                      create_vector_index(collection_endpoint, index_name, awsauth)
                      time.sleep(30)
                  elif event['RequestType'] == 'Delete':
                      delete_index(collection_endpoint, index_name, awsauth)

                  send_cfn_response(event, context, 'SUCCESS', {"message": "Operation completed successfully"})
              except Exception as e:
                  logger.error(f"Error occurred: {str(e)}")
                  logger.error(f"Traceback: {traceback.format_exc()}")
                  send_cfn_response(event, context, 'FAILED', {"error": str(e)})

          def create_vector_index(endpoint, index_name, awsauth):
              url = f'{endpoint}/{index_name}'
              
              index_body = {
                  "settings": {
                      "index.knn": True
                  },
                  "mappings": {
                      "properties": {
                          "vector": {
                              "type": "knn_vector",
                              "dimension": 1536,
                              "method": {
                                  "name": "hnsw",
                                  "space_type": "l2",
                                  "engine": "faiss"
                              }
                          }
                      }
                  }
              }

              headers = {"Content-Type": "application/json"}
              
              logger.info(f"Attempting to create index {index_name}")
              logger.info(f"Request URL: {url}")
              logger.info(f"Request body: {json.dumps(index_body)}")
              
              try:
                  response = requests.put(url, auth=awsauth, json=index_body, headers=headers)
                  logger.info(f"Index creation response status: {response.status_code}")
                  logger.info(f"Index creation response body: {response.text}")
                  response.raise_for_status()
              except requests.exceptions.RequestException as e:
                  logger.error(f"Request failed: {e}")
                  if hasattr(e, 'response'):
                      logger.error(f"Response status code: {e.response.status_code}")
                      logger.error(f"Response body: {e.response.text}")
                  raise

          def delete_index(endpoint, index_name, awsauth):
              url = f'{endpoint}/{index_name}'
              logger.info(f"Attempting to delete index {index_name}")
              logger.info(f"Request URL: {url}")
              try:
                  response = requests.delete(url, auth=awsauth)
                  logger.info(f"Index deletion response status: {response.status_code}")
                  logger.info(f"Index deletion response body: {response.text}")
                  if response.status_code != 404:  # Ignore 404 errors on delete
                      response.raise_for_status()
              except requests.exceptions.RequestException as e:
                  logger.error(f"Request failed: {e}")
                  if hasattr(e, 'response'):
                      logger.error(f"Response status code: {e.response.status_code}")
                      logger.error(f"Response body: {e.response.text}")
                  if response.status_code != 404:  # Ignore 404 errors on delete
                      raise
      Runtime: python3.8
      Timeout: 300
      MemorySize: 256

  AttachPolicyLambda:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import json
          import traceback
          import time
          import random
          import string
          import base64

          def clean_policy_name(policy_name):
              """Clean the policy name to ensure it matches AWS requirements."""
              # Remove any pipe characters and their prefixes
              cleaned_name = policy_name.split('|')[-1] if '|' in policy_name else policy_name
              # Ensure the name starts with a letter and only contains allowed characters
              cleaned_name = ''.join(c for c in cleaned_name if c.isalnum() or c == '-')
              if not cleaned_name[0].isalpha():
                  cleaned_name = 'p-' + cleaned_name
              return cleaned_name.lower()

          def generate_policy_version():
              timestamp = int(time.time())
              random_string = ''.join(random.choices(string.ascii_lowercase + string.digits, k=10))
              version_string = f"{timestamp}-{random_string}"
              return base64.b64encode(version_string.encode()).decode().rstrip('=')

          def handler(event, context):
              client = boto3.client('opensearchserverless')
              
              try:
                  print(f"Received event: {json.dumps(event)}")
                  
                  if event['RequestType'] in ['Create', 'Update']:
                      policy_name = event['ResourceProperties']['PolicyName']
                      policy_name = clean_policy_name(policy_name)
                      collection_name = event['ResourceProperties']['CollectionName']
                      iam_role_arn = event['ResourceProperties']['IAMRoleArn']
                      kb_role_arn = event['ResourceProperties']['KBRoleArn']
                      user_role_arn = event['ResourceProperties']['IAMUserArn']

                      policy_version = generate_policy_version()
                      print(f"Generated policy version: {policy_version}")

                      print(f"IAM Role ARN: {iam_role_arn}")
                      existing_policy = client.get_access_policy(name=policy_name, type='data')
                      print(f"existing Policy content: {json.dumps(existing_policy)}")

                      latest_version = existing_policy['accessPolicyDetail']['policyVersion']

                      print(f"Latest policy version: {latest_version}")

                      policy = [{
                          "Rules": [{
                              "ResourceType": "collection",
                              "Resource": [f"collection/{collection_name}"],
                              "Permission": ["aoss:*"]
                          },
                          {
                              "ResourceType": "index",
                              "Resource": [f"index/{collection_name}/*"],
                              "Permission": [
                                "aoss:CreateIndex",
                                "aoss:UpdateIndex",
                                "aoss:DescribeIndex",
                                "aoss:ReadDocument",
                                "aoss:WriteDocument",
                                "aoss:*"
                            ]
                          }],
                          "Principal": [iam_role_arn,kb_role_arn,user_role_arn]
                      }]
                      
                      print(f"Updating policy: {policy_name}")
                      print(f"Policy content: {json.dumps(policy)}")
                      
                      response = client.update_access_policy(
                          name=policy_name,
                          type='data',
                          description='Updated by CloudFormation',
                          policy=json.dumps(policy),
                          policyVersion=latest_version
                      )
                      
                      print(f"Update policy response: {json.dumps(response)}")
                  
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
              except Exception as e:
                  print(f"Error: {str(e)}")
                  print(f"Traceback: {traceback.format_exc()}")
                  cfnresponse.send(event, context, cfnresponse.FAILED, {"Error": str(e)})
      Runtime: python3.8
      Timeout: 60
      MemorySize: 128

  VectorIndexUpdate:
    Type: Custom::OpenSearchServerlessVectorIndex
    Properties:
      ServiceToken: !GetAtt OpenSearchVectorIndexLambda.Arn
      CollectionName: !Ref AOSSCollectionName
      IndexName: !Ref AOSSIndexName
    UpdateReplacePolicy: Retain
    DeletionPolicy: Retain
    DependsOn: Collection

  OpenSearchServerlessCollectionPolicyAttachment:
    Type: Custom::OpenSearchServerlessCollectionPolicyAttachment
    Properties:
      ServiceToken: !GetAtt AttachPolicyLambda.Arn
      CollectionName: !Ref AOSSCollectionName
      PolicyName: !Ref DataAccessPolicy
      IAMRoleArn: !GetAtt LambdaExecutionRole.Arn
      KBRoleArn: !GetAtt AmazonBedrockExecutionRoleForKnowledgeBase.Arn
      IAMUserArn: !GetAtt AdminUser.Arn
    DependsOn: 
      - Collection
      - DataAccessPolicy

  AmazonBedrockExecutionRoleForAgentsQA5:
    Type: AWS::IAM::Role
    Properties:
      RoleName: AmazonBedrockExecutionRoleForAgents_QA5
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: bedrock.amazonaws.com
          Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonBedrockFullAccess

  KnowledgeBaseWithAoss:
    Type: AWS::Bedrock::KnowledgeBase
    DependsOn: 
      - Collection
      - VectorIndexUpdate
    Properties:
      Name: !Join
      - "-"
      - - "leapkb"
        - !Select
          - 0
          - !Split
            - "-"
            - !Select
              - 2
              - !Split
                - "/"
                - !Ref "AWS::StackId"
      Description: !Ref KnowledgeBaseDescription
      RoleArn: !GetAtt AmazonBedrockExecutionRoleForKnowledgeBase.Arn
      KnowledgeBaseConfiguration:
        Type: "VECTOR"
        VectorKnowledgeBaseConfiguration:
          EmbeddingModelArn: !Sub "arn:${AWS::Partition}:bedrock:${AWS::Region}::foundation-model/amazon.titan-embed-text-v1"
      StorageConfiguration:
        Type: "OPENSEARCH_SERVERLESS"
        OpensearchServerlessConfiguration:
          CollectionArn: !GetAtt Collection.Arn
          VectorIndexName: !Ref AOSSIndexName
          FieldMapping:
            VectorField: "vector"
            TextField: "text"
            MetadataField: "metadata"

  SampleDataSource:
    Type: AWS::Bedrock::DataSource
    DependsOn: KnowledgeBaseWithAoss
    Properties:
      KnowledgeBaseId: !Ref KnowledgeBaseWithAoss
      Name: !Ref S3Bucket
      DataSourceConfiguration:
        Type: "S3"
        S3Configuration:
          BucketArn: !GetAtt S3Bucket.Arn
      DataDeletionPolicy: RETAIN

  AgentResource:
    Type: AWS::Bedrock::Agent
    DependsOn: 
      - KnowledgeBaseWithAoss
      - AmazonBedrockExecutionRoleForAgentsQA5
    Properties:
      AgentName: !Ref AgentName
      AgentResourceRoleArn: !GetAtt AmazonBedrockExecutionRoleForAgentsQA5.Arn
      AutoPrepare: true
      FoundationModel: "amazon.nova-pro-v1:0"
      Instruction: "You are a helpful assistant who can answer questions about a broad range of topics and information that you have access to"
      Description: "AI Agent Bot powered by Amazon Bedrock"
      IdleSessionTTLInSeconds: 900
      MemoryConfiguration:
        EnabledMemoryTypes:
          - SESSION_SUMMARY
        StorageDays: 30
      KnowledgeBases:
        - KnowledgeBaseId: !Ref KnowledgeBaseWithAoss
          Description: !Ref KnowledgeBaseDescription
          KnowledgeBaseState: ENABLED

  BedrockAgentAlias:
    Type: 'AWS::Bedrock::AgentAlias'
    DependsOn: 
      - AgentResource
    Properties:
      AgentId: !Ref AgentResource
      AgentAliasName: 'prodalias'

  # IAM Role for Lambda (unchanged)
  AgentLambdaExecutionRole:
    Type: AWS::IAM::Role
    DependsOn:
      - ChatLogTable
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource: !GetAtt ChatLogTable.Arn
        - PolicyName: BedrockAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:InvokeAgent
                  - bedrock-agent-runtime:InvokeAgent
                  - bedrock:ListFoundationModels
                  - bedrock:InvokeModel
                  - bedrock:StartIngestionJob
                  - bedrock-agent:StartIngestionJob
                  - bedrock-agent:GetIngestionJob
                  - bedrock-agent:ListIngestionJobs
                Resource: '*'

  # Lambda Function (unchanged)
  LambdaFunction:
    Type: AWS::Lambda::Function
    DependsOn:
      - AgentResource
      - BedrockAgentAlias
      - KnowledgeBaseWithAoss
    Properties:
      Handler: index.lambda_handler
      Role: !GetAtt AgentLambdaExecutionRole.Arn
      Environment:
        Variables:
          BEDROCK_AGENT_ID: !Ref AgentResource
          BEDROCK_ALIAS_ID: !GetAtt BedrockAgentAlias.AgentAliasId
          DYNAMODB_TABLE_NAME: !Ref ChatLogTable
          KNOWLEDGE_BASE_ID: !Ref KnowledgeBaseWithAoss
          DATA_SOURCE_ID: !GetAtt SampleDataSource.DataSourceId
      Code:
        ZipFile: |
          import json
          import boto3
          import logging
          import os
          from botocore.exceptions import ClientError
          import uuid
          import re
          import time
          from datetime import datetime

          def extract_token_usage_from_trace(trace_data):
              """Extract token usage information from trace data"""
              if isinstance(trace_data, dict):
                  if 'usage' in trace_data:
                      return trace_data['usage'].get('inputTokens', 0), trace_data['usage'].get('outputTokens', 0)
                  
                  # Recursively search in nested dictionaries
                  for key, value in trace_data.items():
                      if isinstance(value, dict):
                          input_tokens, output_tokens = extract_token_usage_from_trace(value)
                          if input_tokens > 0 or output_tokens > 0:
                              return input_tokens, output_tokens
              
              return 0, 0

          def sync():

              bedrock_agent = boto3.client('bedrock-agent', region_name='us-east-1')

              headers = {
                  'Access-Control-Allow-Origin': '*', 
                  'Access-Control-Allow-Headers': 'Content-Type,Authorization',
                  'Access-Control-Allow-Methods': 'OPTIONS,POST'
              }
                        
              try:
                  # Default Knowledge Base and Data Source IDs from environment variables
                  knowledge_base_id = os.environ.get('KNOWLEDGE_BASE_ID', '')
                  data_source_id = os.environ.get('DATA_SOURCE_ID', '')
                                    
                  logger.info(f"Starting sync for Knowledge Base ID: {knowledge_base_id}, Data Source ID: {data_source_id}")
                  
                  # Start the data source sync job
                  response = bedrock_agent.start_ingestion_job(
                      knowledgeBaseId=knowledge_base_id,
                      dataSourceId=data_source_id
                  )
                  
                  ingestion_job_id = response['ingestionJob']['ingestionJobId']
                  
                  logger.info(f"Ingestion job started successfully. Job ID: {ingestion_job_id}")
                  
                  return {
                      'statusCode': 200,
                      'headers': headers,
                      'body': json.dumps({
                          'message': 'Knowledge Base sync started successfully',
                          'ingestionJobId': ingestion_job_id,
                          'status': 'STARTED',
                          'knowledgeBaseId': knowledge_base_id,
                          'dataSourceId': data_source_id
                      })
                  }
                  
              except ClientError as e:
                  error_message = e.response['Error']['Message']
                  error_code = e.response['Error']['Code']
                  logger.error(f"Error syncing Knowledge Base: {error_code} - {error_message}")
                  
                  return {
                      'statusCode': 500,
                      'headers': headers,
                      'body': json.dumps({
                          'error': f"Failed to sync Knowledge Base: {error_code}",
                          'message': error_message
                      })
                  }
              except Exception as e:
                  logger.error(f"Unexpected error: {str(e)}")
                  
                  return {
                      'statusCode': 500,
                      'headers': headers,
                      'body': json.dumps({
                          'error': 'Internal server error',
                          'message': str(e)
                      })
                  }

          # Set up logging
          logger = logging.getLogger()
          #logger.setLevel(logging.INFO)
          class BytesEncoder(json.JSONEncoder):
              def default(self, obj):
                  if isinstance(obj, bytes):
                      return obj.decode('utf-8', errors='replace')
                  return super().default(obj)

          def log_to_dynamodb(request_id, timestamp, user_message, bot_response, latency, client_ip, status_code, error=None, bedrock_latency=None, input_tokens=None, output_tokens=None, total_tokens=None, model_id=None, model_version=None):
              """
              Logs chat information to DynamoDB
              """
              try:
                  # Initialize DynamoDB client
                  dynamodb = boto3.resource('dynamodb')
                  table_name = None
                  
                  # Get the DynamoDB table name from environment variables
                  import os
                  table_name = os.environ.get('DYNAMODB_TABLE_NAME')
                  
                  # Use default name if environment variable not found
                  if not table_name:
                      # Default table name as fallback
                      table_name = "bedrock-chat-logs"
                      print(f"Warning: Using default table name: {table_name}")
                  
                  table = dynamodb.Table(table_name)
                  
                  # Create the item to store
                  item = {
                      'id': request_id,
                      'timestamp': timestamp,
                      'user_message': user_message[:1000] if user_message else "",  # Truncate if too long
                      'bot_response': bot_response[:1000] if bot_response else "",  # Truncate if too long
                      'latency_ms': int(latency * 1000),  # Convert to milliseconds
                      'client_ip': client_ip,
                      'status_code': status_code,
                      'date': datetime.fromtimestamp(timestamp/1000).strftime('%Y-%m-%d'),
                  }
                  
                  # Add optional fields if they exist
                  if error:
                      item['error'] = error[:1000]  # Truncate if too long
                  
                  if bedrock_latency is not None:
                      item['bedrock_latency_ms'] = int(bedrock_latency * 1000)  # Convert to milliseconds
                  
                  # Add token usage information if available
                  if input_tokens is not None:
                      item['input_tokens'] = input_tokens
                  
                  if output_tokens is not None:
                      item['output_tokens'] = output_tokens
                      
                  if total_tokens is not None:
                      item['total_tokens'] = total_tokens
                      
                  # Add model information if available
                  if model_id is not None:
                      item['model_id'] = model_id
                      
                  if model_version is not None:
                      item['model_version'] = model_version
                  
                  # Store in DynamoDB
                  table.put_item(Item=item)
                  print(f"Logged to DynamoDB: {request_id}")
                  
              except Exception as e:
                  print(f"Error logging to DynamoDB: {str(e)}")
                  # Don't re-raise the exception to avoid breaking the main function

          def parseparam(event):
            try:
                message=''
                
                # Check if message is directly in event (test invoke)
                if isinstance(event, dict) and 'message' in event:
                    message = event['message']
                    
                # Check if message is in body (API Gateway POST)
                elif isinstance(event, dict) and 'body' in event:
                    # Handle string body
                    if isinstance(event['body'], str):
                        import json
                        body = json.loads(event['body'])
                    else:
                        body = event['body']
                        
                    message = body.get('message')
                    
                    return message
                    
                else:
                    return ""
                    
                # Process message here
                return message
                
            except Exception as e:
                return ""

          def extract_result_from_raw_response(raw_response):
              print(f"Attempting to extract result from: {raw_response}")  # Debug print
              
              try:
                  # First attempt: try to find result between instruction and end
                  pattern = r'"result":\s*"(.*?)"}'
                  match = re.search(pattern, raw_response, re.DOTALL)
                  if match:
                      result = match.group(1)
                      print(f"Found result using first pattern: {result}")  # Debug print
                      return result
                      
                  # Second attempt: broader pattern
                  pattern = r'"result":\s*"([^}]*)'
                  match = re.search(pattern, raw_response, re.DOTALL)
                  if match:
                      result = match.group(1)
                      print(f"Found result using second pattern: {result}")  # Debug print
                      # Clean up any trailing quotes or backslashes
                      result = result.rstrip('"\\ ')
                      return result
                      
                  # If both patterns fail, print for debugging
                  print("No match found with either pattern")
                  return raw_response
                  
              except Exception as e:
                  print(f"Error in extract_result_from_raw_response: {e}")
                  return None
              
          def lambda_handler(event, context):
              client = boto3.client('bedrock-agent-runtime')
              AGENT_ID = os.environ['BEDROCK_AGENT_ID']
              ALIAS_ID = os.environ['BEDROCK_ALIAS_ID']

              model_id = "amazon.nova-pro-v1:0"

              # Parse request body if provided
              if 'body' in event and event['body']:
                  try:
                      body = json.loads(event['body'])
                      
                      # Override with values from request body if provided
                      if 'sync' in body and body['sync']:
                          return sync()
              
                  except json.JSONDecodeError:
                      logger.warning("Failed to parse request body as JSON")
              
                  
              user_message = parseparam(event)
              session_id = str(uuid.uuid4())

              if 'sessionid' in body and body['sessionid']:
                session_id = body['sessionid']

              start_time = time.time()
              request_id = str(uuid.uuid4())
              timestamp = int(datetime.now().timestamp() * 1000)  # Milliseconds since epoch
              client_ip = event.get('requestContext', {}).get('identity', {}).get('sourceIp', 'unknown')

              # Log the boto3 version
              try:

                  bedrock_start_time = time.time()
                  
                  # Send the message to the Bedrock agent with additional parameters
                  response = client.invoke_agent(
                      agentId=AGENT_ID, #'CYQACSRTBT',
                      agentAliasId=ALIAS_ID, 
                      sessionId=session_id,
                      inputText=user_message,
                      enableTrace=False
                  )

                  bedrock_latency = time.time() - bedrock_start_time
                  
                  enable_trace=True
                  # Process the event stream response
                  full_response = ""
                  # Initialize token counters
                  input_tokens = 0
                  output_tokens = 0
                  
                  for event_dict in response['completion']:
                      # Handle chunk events which contain the actual response
                      if 'chunk' in event_dict:
                          chunk = event_dict['chunk']
                          if 'bytes' in chunk:
                              try:
                                  print(f"Chunk data: {chunk['bytes'].decode('utf-8')}")
                                  # Parse the bytes content as JSON
                                  
                                  chunk_data = json.loads(chunk['bytes'].decode('utf-8'))

                                  if 'result' in chunk_data:
                                      print(f"Found result: {chunk_data['result']}")
                                      full_response += chunk_data['result']
                              except json.JSONDecodeError:
                                  # If not JSON, just decode the bytes directly
                                  print(f"Not JSON event: {chunk['bytes'].decode('utf-8')}")
                  
                                  full_response += extract_result_from_raw_response(chunk['bytes'].decode('utf-8'))
                                  

                      # Extract token usage from trace events
                      elif 'trace' in event_dict:
                          trace_data = event_dict['trace']
                          print(f"Trace event: {json.dumps(trace_data)}")
                          
                          # Try to extract token usage from trace data
                          trace_input, trace_output = extract_token_usage_from_trace(trace_data)
                          if trace_input > 0 or trace_output > 0:
                              input_tokens = trace_input
                              output_tokens = trace_output
                              print(f"Found token usage in trace: input={input_tokens}, output={output_tokens}")
                  
                  # If we didn't find token usage in trace events, check response metadata
                  if input_tokens == 0 and output_tokens == 0:
                      # Check if usage is directly in the response
                      if 'usage' in response:
                          input_tokens = response['usage'].get('inputTokens', 0)
                          output_tokens = response['usage'].get('outputTokens', 0)
                          print(f"Found token usage in response: input={input_tokens}, output={output_tokens}")
                      # Check if usage is in response metadata
                      elif 'ResponseMetadata' in response:
                          headers = response['ResponseMetadata'].get('HTTPHeaders', {})
                          if 'x-amzn-bedrock-input-token-count' in headers:
                              input_tokens = int(headers.get('x-amzn-bedrock-input-token-count', 0))
                              output_tokens = int(headers.get('x-amzn-bedrock-output-token-count', 0))
                              print(f"Found token usage in headers: input={input_tokens}, output={output_tokens}")
                      
                  if not full_response:
                      full_response = "Unable to process response. Please check CloudWatch logs."
                      
                  full_response = full_response.strip()
                  full_response = full_response.replace('\n', '<br>')

                  
                  total_tokens = input_tokens + output_tokens
                  
                  
                  
                  # Calculate total latency
                  total_latency = time.time() - start_time
                  
                  # Log successful request to DynamoDB
                  log_to_dynamodb(
                      request_id=request_id,
                      timestamp=timestamp,
                      user_message=user_message,
                      bot_response=full_response,
                      latency=total_latency,
                      bedrock_latency=bedrock_latency,
                      client_ip=client_ip,
                      status_code=200,
                      error=None,
                      input_tokens=input_tokens,
                      output_tokens=output_tokens,
                      total_tokens=total_tokens,
                      model_id=model_id
                  )
                  
                  result = {
                      'message': 'Successfully sent message to Bedrock agent',
                      'result': full_response,
                  }
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps(result),
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token',
                          'Access-Control-Allow-Methods': 'GET,POST,OPTIONS'
                      }
                  }
              except ClientError as e:
                  logger.error(f"Bedrock Agent ClientError: {e}")
                  return {
                      'statusCode': 400,
                      'body': json.dumps({
                          'message': 'Error invoking Bedrock agent',
                          'error': str(e)
                      }, cls=BytesEncoder),
                      'headers': {
                          'Access-Control-Allow-Origin': '*'
                      }
                  }
              except Exception as e:
                  error_str = str(e)
                  logger.error(f"Unexpected error: {e}")
                  logger.error(f"Event: {event}")

                  try:
                      # Try to log the error to DynamoDB
                      log_to_dynamodb(
                          request_id=request_id if 'request_id' in locals() else str(uuid.uuid4()),
                          timestamp=timestamp if 'timestamp' in locals() else int(datetime.now().timestamp() * 1000),
                          user_message=user_message if 'user_message' in locals() else "",
                          bot_response="",
                          latency=time.time() - start_time if 'start_time' in locals() else 0,
                          client_ip=client_ip if 'client_ip' in locals() else "unknown",
                          status_code=500,
                          model_id=model_id,
                          error=f"General error: {error_str}"
                      )
                  except Exception as log_error:
                      print(f"Failed to log error to DynamoDB: {str(log_error)}")

                  return {
                      'statusCode': 500,
                      'body': json.dumps({
                          'message': 'Unexpected error when sending message to Bedrock agent',
                          'error': str(e),
                          'event': event
                      }, cls=BytesEncoder),
                      'headers': {
                          'Access-Control-Allow-Origin': '*'
                      }
                  }

      Runtime: python3.9
      Timeout: 30
      MemorySize: 128

  # API Gateway REST API
  ApiGateway:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: BedrockAgentAPI
      Description: API Gateway for Bedrock Agent Lambda function
      EndpointConfiguration:
        Types:
          - REGIONAL

  # Proxy Resource to handle all paths
  ProxyResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: chat

  # Proxy ANY Method
  ProxyMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ProxyResource
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 
          - arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${LambdaArn}/invocations
          - LambdaArn: !GetAtt LambdaFunction.Arn
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true

  ####
  OptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: NONE
      HttpMethod: OPTIONS
      ResourceId: !Ref ProxyResource
      RestApiId: !Ref ApiGateway
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'GET,POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates:
              application/json: ''
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

  ApiDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - ProxyMethod
      - OptionsMethod
    Properties:
      RestApiId: !Ref ApiGateway

  ApiStage:
    Type: AWS::ApiGateway::Stage
    Properties:
      DeploymentId: !Ref ApiDeployment
      RestApiId: !Ref ApiGateway
      StageName: prod

  

  # Lambda Permission for API Gateway
  LambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt LambdaFunction.Arn
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGateway}/*/*/*

  # S3 Bucket Cleanup Function
  S3CleanupRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: S3CleanupPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:ListBucket
                  - s3:DeleteObject
                  - s3:DeleteObjectVersion
                  - s3:GetObjectVersion
                  - s3:ListBucketVersions
                Resource: 
                  - !Sub 'arn:aws:s3:::${PrivateS3Bucket}'
                  - !Sub 'arn:aws:s3:::${PrivateS3Bucket}/*'
                  - !Sub 'arn:aws:s3:::${S3Bucket}'
                  - !Sub 'arn:aws:s3:::${S3Bucket}/*'

  S3CleanupFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.handler
      Role: !GetAtt S3CleanupRole.Arn
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import logging
          import time

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def delete_bucket_contents(bucket_name):
              try:
                  logger.info(f"Starting cleanup of bucket: {bucket_name}")
                  s3 = boto3.client('s3')
                  
                  # Delete all object versions
                  paginator = s3.get_paginator('list_object_versions')
                  pages = paginator.paginate(Bucket=bucket_name)
                  
                  delete_list = []
                  
                  try:
                      for page in pages:
                          # Handle versions
                          if 'Versions' in page:
                              for version in page['Versions']:
                                  delete_list.append({
                                      'Key': version['Key'],
                                      'VersionId': version['VersionId']
                                  })
                          
                          # Handle delete markers
                          if 'DeleteMarkers' in page:
                              for marker in page['DeleteMarkers']:
                                  delete_list.append({
                                      'Key': marker['Key'],
                                      'VersionId': marker['VersionId']
                                  })
                          
                          if delete_list:
                              logger.info(f"Deleting {len(delete_list)} objects")
                              s3.delete_objects(
                                  Bucket=bucket_name,
                                  Delete={'Objects': delete_list}
                              )
                              delete_list = []
                      
                      # Final check for non-versioned objects
                      paginator = s3.get_paginator('list_objects_v2')
                      pages = paginator.paginate(Bucket=bucket_name)
                      
                      for page in pages:
                          if 'Contents' in page:
                              objects = [{'Key': obj['Key']} for obj in page['Contents']]
                              if objects:
                                  logger.info(f"Deleting {len(objects)} non-versioned objects")
                                  s3.delete_objects(
                                      Bucket=bucket_name,
                                      Delete={'Objects': objects}
                                  )
                      
                      logger.info(f"Successfully cleaned up bucket: {bucket_name}")
                      return True
                      
                  except Exception as e:
                      logger.error(f"Error during deletion: {str(e)}")
                      return False
                      
              except Exception as e:
                  logger.error(f"Error accessing bucket: {str(e)}")
                  return False

          def handler(event, context):
              logger.info('Received event: %s', event)
              response_data = {}
              
              try:
                  bucket_name = event['ResourceProperties']['BucketName']
                  
                  if event['RequestType'] == 'Delete':
                      # Attempt cleanup multiple times
                      max_attempts = 3
                      for attempt in range(max_attempts):
                          logger.info(f"Cleanup attempt {attempt + 1} of {max_attempts}")
                          if delete_bucket_contents(bucket_name):
                              break
                          if attempt < max_attempts - 1:
                              time.sleep(5)  # Wait before retry
                  
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)
                  
              except Exception as e:
                  logger.error(f"Error in handler: {str(e)}")
                  cfnresponse.send(event, context, cfnresponse.FAILED, response_data)

      Runtime: python3.9
      Timeout: 300  # Increased timeout to 5 minutes
      MemorySize: 256  # Increased memory

  PrivateS3Bucket:
    Type: 'AWS::S3::Bucket'
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: 'AES256'
      VersioningConfiguration:
        Status: Enabled

  BucketCleanupResource:
    Type: Custom::S3Cleanup
    DependsOn: PrivateS3Bucket
    Properties:
      ServiceToken: !GetAtt S3CleanupFunction.Arn
      BucketName: !Ref PrivateS3Bucket


  BucketPolicy:
    Type: 'AWS::S3::BucketPolicy'
    Properties:
      Bucket: !Ref PrivateS3Bucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: DenyUnsecuredTransport
            Effect: Deny
            Principal: '*'
            Action: 's3:*'
            Resource: 
              - !Sub '${PrivateS3Bucket.Arn}/*'
              - !GetAtt PrivateS3Bucket.Arn
            Condition:
              Bool:
                'aws:SecureTransport': false

  S3UploaderRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: S3UploadAndSignPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:PutObject
                  - s3:GetObject
                Resource: !Sub '${PrivateS3Bucket.Arn}/*'

  S3UploaderFunction:
    Type: 'AWS::Lambda::Function'
    DependsOn:
      - ApiGateway
      - ApiStage
    Properties:
      Handler: index.handler
      Role: !GetAtt S3UploaderRole.Arn
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          
          def handler(event, context):
              if event['RequestType'] in ['Create', 'Update']:
                  try:
                      s3 = boto3.client('s3')
                      bucket_name = event['ResourceProperties']['BucketName']
                      api_gateway = event['ResourceProperties']['ApiGateway']
                      aws_region = event['ResourceProperties']['AWSReg']
                      
                      # HTML content
                      html_content = """
                      <!DOCTYPE html>
                        <html>
                        <head>
                            <title>Chat with your documents</title>
                            <style>
                                body { 
                                    font-family: Arial, sans-serif; 
                                    max-width: 800px; 
                                    margin: 0 auto; 
                                    padding: 20px;
                                    background-color: #f5f5f5;
                                }
                                #chat-container { 
                                    height: 500px; 
                                    overflow-y: auto; 
                                    border: 1px solid #ddd; 
                                    padding: 20px;
                                    background-color: white;
                                    border-radius: 8px;
                                    margin-bottom: 20px;
                                }
                                #input-container { 
                                    display: flex; 
                                    gap: 10px;
                                    margin-bottom: 20px;
                                }
                                #message-input { 
                                    flex-grow: 1; 
                                    padding: 10px;
                                    border: 1px solid #ddd;
                                    border-radius: 4px;
                                    font-size: 16px;
                                }
                                button {
                                    padding: 10px 20px;
                                    background-color: #007bff;
                                    color: white;
                                    border: none;
                                    border-radius: 4px;
                                    cursor: pointer;
                                }
                                button:hover {
                                    background-color: #0056b3;
                                }
                                .message {
                                    margin-bottom: 15px;
                                    padding: 10px;
                                    border-radius: 4px;
                                    max-width: 80%;
                                }
                                .user-message {
                                    background-color: #007bff;
                                    color: white;
                                    margin-left: auto;
                                }
                                .assistant-message {
                                    background-color: #e9ecef;
                                    color: black;
                                }
                                #loading {
                                    display: none;
                                    text-align: center;
                                    color: #666;
                                    padding: 10px;
                                }
                                #notification {
                                    position: fixed;
                                    top: 20px;
                                    right: 20px;
                                    padding: 10px 20px;
                                    border-radius: 4px;
                                    color: white;
                                    z-index: 1000;
                                    opacity: 0;
                                    transition: opacity 0.3s ease-in-out;
                                }
                            </style>
                        </head>
                        <body>
                            <h1>Agent chat with documents  <button style="float:right;background:#64748b" id="sync-button" onclick="syncKnowledgeBase()">Sync Knowledge Base</button></h1>
                            <!--<button id="sync-button" onclick="syncKnowledgeBase()">Sync Knowledge Base</button>-->
                            <div id="chat-container"></div>
                            <div id="loading">Assistant is typing...</div>
                            <div id="input-container">
                                <input type="text" id="message-input" placeholder="Type your message...">
                                <button id="send-button" onclick="sendMessage()">Send</button>
                            </div>
                            <script>
                                function generateSessionString() {
                                    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
                                    let result = '';
                                    for (let i = 0; i < 8; i++) {
                                        result += chars.charAt(Math.floor(Math.random() * chars.length));
                                    }
                                    return result;
                                }          

                                var sessionid = generateSessionString();
                                const apiUrl = 'AAAAA.execute-api.RRRR.amazonaws.com/prod/chat';
                                const messageInput = document.getElementById('message-input');
                                const chatContainer = document.getElementById('chat-container');
                                const loadingIndicator = document.getElementById('loading');
                                const sendButton = document.getElementById('send-button');

                                let lastMessage = '';
                                let isProcessing = false;
                                
                                messageInput.addEventListener('keypress', function(e) {
                                    if (e.key === 'Enter') {
                                        sendMessage();
                                    }
                                });

                                document.addEventListener('DOMContentLoaded', function () {
                                    checkUrlParameters();
                                });

                                // Helper function to show notifications
                                function showNotification(message, type = 'info') {
                                    // Create notification element if it doesn't exist
                                    let notification = document.getElementById('notification');
                                    if (!notification) {
                                        notification = document.createElement('div');
                                        notification.id = 'notification';
                                        document.body.appendChild(notification);
                                    }

                                    // Set color based on notification type
                                    if (type === 'success') {
                                        notification.style.backgroundColor = '#4CAF50';
                                    } else if (type === 'error') {
                                        notification.style.backgroundColor = '#F44336';
                                    } else {
                                        notification.style.backgroundColor = '#2196F3';
                                    }

                                    // Set message and show notification
                                    notification.textContent = message;
                                    notification.style.opacity = '1';

                                    // Hide notification after 5 seconds
                                    setTimeout(() => {
                                        notification.style.opacity = '0';
                                    }, 5000);
                                }

                                // Function to check URL parameters and trigger actions
                                function checkUrlParameters() {
                                    const urlParams = new URLSearchParams(window.location.search);

                                    // Check if sync parameter is present
                                    if (urlParams.has('sync')) {
                                        const syncValue = urlParams.get('sync');
                                        if (syncValue === 'true' || syncValue === '1') {
                                            console.log('Auto-triggering Knowledge Base sync from URL parameter');
                                            // Trigger sync with a slight delay to ensure page is fully loaded
                                            setTimeout(() => {
                                                syncKnowledgeBase()
                                                    .then(result => {
                                                        if (result.success) {
                                                            // If redirect parameter is present, redirect after successful sync
                                                            if (urlParams.has('redirect')) {
                                                                const redirectUrl = urlParams.get('redirect');
                                                                if (redirectUrl) {
                                                                    setTimeout(() => {
                                                                        window.location.href = redirectUrl;
                                                                    }, 2000); // Give time for notification to be seen
                                                                }
                                                            }
                                                        }
                                                    });
                                            }, 1000);
                                        }
                                    }

                                    // Check if we should display a custom message
                                    if (urlParams.has('message')) {
                                        const message = urlParams.get('message');
                                        const messageType = urlParams.has('messageType') ? urlParams.get('messageType') : 'info';
                                        if (message) {
                                            showNotification(decodeURIComponent(message), messageType);
                                        }
                                    }
                                }

                              // Function to sync the Knowledge Base data source
                                async function syncKnowledgeBase() {
                                    // Show loading indicator
                                    const syncButton = document.getElementById('sync-button');
                                    const originalText = syncButton.textContent;
                                    syncButton.disabled = true;
                                    syncButton.textContent = 'Syncing...';
                                    
                                    sessionid = generateSessionString();

                                    // API Gateway endpoint for Knowledge Base sync

                                    try {
                                        
                                        const response = await fetch('https://' +apiUrl, {
                                            method: 'POST',
                                            headers: {
                                                'Content-Type': 'application/json'
                                            },
                                            body: JSON.stringify({sync:true})
                                        });

                                        const data = await response.json();

                                        if (response.ok) {
                                            showNotification('Knowledge Base sync started successfully!', 'success');
                                            console.log('Sync job ID:', data.ingestionJobId);
                                        } else {
                                            showNotification(`Failed to sync Knowledge Base: ${data.error}`, 'error');
                                            console.error('Error details:', data.message);
                                        }

                                    } catch (error) {
                                        console.error('Sync error:', error);
                                        showNotification('Failed to connect to sync service', 'error');
                                    } finally {
                                        // Reset button state
                                        syncButton.disabled = false;
                                        syncButton.textContent = originalText;
                                    }
                                }
                                
                                function setProcessingState(processing) {
                                      isProcessing = processing;
                                      sendButton.disabled = processing;
                                      messageInput.disabled = processing;
                                      loadingIndicator.style.display = processing ? 'block' : 'none';
                                  }

                                  function parseErrorMessage(error) {
                                      // Handle different types of errors
                                      if (typeof error === 'string') {
                                          if (error.includes('throttlingException') || error.includes('rate is too high')) {
                                              return {
                                                  type: 'throttling',
                                                  userMessage: 'Too many requests - please wait a moment before trying again',
                                                  details: 'The service is currently receiving too many requests. Please reduce the frequency of your messages.',
                                                  canRetry: true,
                                                  retryDelay: 20000 // 10 seconds
                                              };
                                          } else if (error.includes('ValidationException')) {
                                              return {
                                                  type: 'validation',
                                                  userMessage: 'Invalid request format',
                                                  details: 'The request format is invalid. Please try rephrasing your message.',
                                                  canRetry: true,
                                                  retryDelay: 0
                                              };
                                          } else if (error.includes('AccessDeniedException')) {
                                              return {
                                                  type: 'access',
                                                  userMessage: 'Access denied - insufficient permissions',
                                                  details: 'The system does not have permission to process this request.',
                                                  canRetry: false
                                              };
                                          } else if (error.includes('InternalServerException')) {
                                              return {
                                                  type: 'server',
                                                  userMessage: 'Internal server error - please try again later',
                                                  details: 'An internal error occurred. Please try again in a few minutes.',
                                                  canRetry: true,
                                                  retryDelay: 30000 // 30 seconds
                                              };
                                          } else if (error.includes('timeout') || error.includes('TimeoutError')) {
                                              return {
                                                  type: 'timeout',
                                                  userMessage: 'Request timed out - please try again',
                                                  details: 'The request took too long to process. Please try again.',
                                                  canRetry: true,
                                                  retryDelay: 5000 // 5 seconds
                                              };
                                          } else if (error.includes('ModelNotReadyException')) {
                                              return {
                                                  type: 'model',
                                                  userMessage: 'AI model is currently unavailable',
                                                  details: 'The AI model is not ready. Please try again in a few minutes.',
                                                  canRetry: true,
                                                  retryDelay: 60000 // 60 seconds
                                              };
                                          }
                                      }

                                      // Default error handling
                                      return {
                                          type: 'unknown',
                                          userMessage: 'An unexpected error occurred',
                                          details: error || 'Please try again or contact support if the problem persists.',
                                          canRetry: true,
                                          retryDelay: 5000
                                      };
                                  }

                                  function createRetryButton(message, delay = 0) {
                                      const retryButton = document.createElement('button');
                                      retryButton.className = 'retry-button';
                                      retryButton.textContent = delay > 0 ? `Retry in ${Math.ceil(delay / 1000)}s` : 'Retry';

                                      if (delay > 0) {
                                          retryButton.disabled = true;
                                          let remainingTime = delay;
                                          const countdown = setInterval(() => {
                                              remainingTime -= 1000;
                                              if (remainingTime <= 0) {
                                                  clearInterval(countdown);
                                                  retryButton.disabled = false;
                                                  retryButton.textContent = 'Retry';
                                              } else {
                                                  retryButton.textContent = `Retry in ${Math.ceil(remainingTime / 1000)}s`;
                                              }
                                          }, 1000);
                                      }

                                      retryButton.onclick = () => {
                                          if (!retryButton.disabled) {
                                              messageInput.value = message;
                                              sendMessage();
                                          }
                                      };

                                      return retryButton;
                                  }

                                  async function sendMessage() {
                                      const message = messageInput.value.trim();
                                      if (!message || isProcessing) return;

                                      lastMessage = message;
                                      messageInput.value = '';
                                      setProcessingState(true);

                                      appendMessageToChat(message, 'user');

                                      try {
                                          const response = await fetch('https://' + apiUrl, {
                                              method: 'POST',
                                              headers: {
                                                  'Content-Type': 'application/json'
                                              },
                                              body: JSON.stringify({ message: message, sessionid: sessionid })
                                          });

                                          const responseData = await response.json();

                                          setProcessingState(false);

                                          if (!response.ok || responseData.message?.includes('Error')) {
                                              // Handle API errors
                                              const errorInfo = parseErrorMessage(responseData.error || responseData.message || 'Unknown error');
                                              appendErrorMessage(errorInfo, message);
                                          } else if (responseData.result) {
                                              // Successful response
                                              appendMessageToChat(responseData.result, 'assistant');
                                          } else {
                                              // Unexpected response format
                                              const errorInfo = parseErrorMessage('Unexpected response format');
                                              appendErrorMessage(errorInfo, message);
                                          }

                                      } catch (error) {
                                          console.error('Network Error:', error);
                                          setProcessingState(false);

                                          let errorInfo;
                                          if (error.name === 'TypeError' && error.message.includes('fetch')) {
                                              errorInfo = {
                                                  type: 'network',
                                                  userMessage: 'Network connection error',
                                                  details: 'Unable to connect to the server. Please check your internet connection.',
                                                  canRetry: true,
                                                  retryDelay: 5000
                                              };
                                          } else {
                                              errorInfo = parseErrorMessage(error.message);
                                          }

                                          appendErrorMessage(errorInfo, message);
                                      }
                                  }

                                  function appendMessageToChat(messageText, senderType) {
                                      const messageElement = document.createElement('div');
                                      messageElement.className = 'message ' + senderType + '-message';

                                      // Handle HTML content in assistant messages (like line breaks)
                                      if (senderType === 'assistant' && messageText.includes('<br>')) {
                                          messageElement.innerHTML = messageText;
                                      } else {
                                          messageElement.textContent = messageText;
                                      }

                                      chatContainer.appendChild(messageElement);
                                      chatContainer.scrollTop = chatContainer.scrollHeight;
                                  }

                                  function appendErrorMessage(errorInfo, originalMessage) {
                                      const messageElement = document.createElement('div');
                                      messageElement.className = 'message error-message';

                                      const mainText = document.createElement('div');
                                      mainText.textContent = errorInfo.userMessage;
                                      messageElement.appendChild(mainText);

                                      const detailsText = document.createElement('div');
                                      detailsText.className = 'error-details';
                                      detailsText.textContent = errorInfo.details;
                                      messageElement.appendChild(detailsText);

                                      if (errorInfo.canRetry) {
                                          const retryButton = createRetryButton(originalMessage, errorInfo.retryDelay);
                                          messageElement.appendChild(retryButton);
                                      }

                                      chatContainer.appendChild(messageElement);
                                      chatContainer.scrollTop = chatContainer.scrollHeight;
                                  }
                            </script>
                        </body>
                        </html>
                      """
                      
                      html_content = html_content.replace('AAAAA', api_gateway)
                      html_content = html_content.replace('RRRR', aws_region)

                      # Upload the HTML file
                      s3.put_object(
                          Bucket=bucket_name,
                          Key='index.html',
                          Body=html_content,
                          ContentType='text/html'
                      )
                      
                      # Generate presigned URL (valid for 7 days - maximum allowed)
                      presigned_url = s3.generate_presigned_url(
                          'get_object',
                          Params={
                              'Bucket': bucket_name,
                              'Key': 'index.html'
                          },
                          ExpiresIn=604800  # 7 days in seconds
                      )
                      
                      responseData = {
                          'SignedURL': presigned_url
                      }
                      
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData)
                  except Exception as e:
                      print(f"Error: {str(e)}")
                      cfnresponse.send(event, context, cfnresponse.FAILED, {})
              else:
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
      Runtime: python3.9
      Timeout: 30

  UploadHTMLAndGenerateURL:
    Type: 'Custom::S3Upload'
    Properties:
      ServiceToken: !GetAtt S3UploaderFunction.Arn
      BucketName: !Ref PrivateS3Bucket
      ApiGateway: !Ref ApiGateway
      AWSReg: !Ref AWS::Region

Outputs:
  DynamoDBTableName:
    Description: 'Name of the created DynamoDB table for chat logs'
    Value: !Ref ChatLogTable
    
  DynamoDBTableArn:
    Description: 'ARN of the created DynamoDB table'
    Value: !GetAtt ChatLogTable.Arn

  S3Bucket:
    Value: !GetAtt S3Bucket.Arn
  S3BucketName:
    Value: !Ref S3Bucket
  S3BucketLink:
    Description: 'Link to the created S3 bucket'
    Value: !Sub https://s3.console.aws.amazon.com/s3/buckets/${S3Bucket}
  DashboardURL:
    Value: !GetAtt Collection.DashboardEndpoint
  AmazonBedrockExecutionRoleForKnowledgeBase:
    Value: !GetAtt AmazonBedrockExecutionRoleForKnowledgeBase.Arn
  CollectionARN:
    Value: !GetAtt Collection.Arn
  AOSSVectorIndexName:
    Description: vector index
    Value: !Ref AOSSIndexName
  Region:
    Description: Deployed Region
    Value: !Ref AWS::Region
  KnowledgeBaseId:
    Description: ID of the created Knowledge Base
    Value: !Ref KnowledgeBaseWithAoss
  AgentId:
    Description: ID of the created Agent
    Value: !Ref AgentResource
  AgentRoleArn:
    Description: ARN of the Agent execution role
    Value: !GetAtt AmazonBedrockExecutionRoleForAgentsQA5.Arn
  LambdaExecutionRoleArn:
    Description: ARN of the Lambda execution role
    Value: !GetAtt LambdaExecutionRole.Arn
  LambdaFunctionName:
    Description: Name of the Lambda function
    Value: !Ref LambdaFunction
  BackendURL:
    Description: 'API Gateway endpoint URL for prod stage'
    Value: !Sub https://${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com/prod/chat
  FrontendURL:
    Description: 'Presigned URL for accessing the HTML file (valid for 7 days)'
    Value: !GetAtt UploadHTMLAndGenerateURL.SignedURL
